/**
 * Superagent powered request
 * https://github.com/yr/agent
 * @copyright Yr
 * @license MIT
 */

'use strict';

const superagent = require('superagent');

const STATUS_TIMEOUT = 504;

const Request = superagent.Request;
const oldEnd = Request.prototype.end;
const oldGet = superagent.get;
let cache = {};

module.exports = superagent;

/**
 * GET request for 'url'
 * @param {String} url
 * @param {Object} [options]
 *  - {Boolean} abort
 *  - {String} id
 *  - {Boolean} ignoreQuery
 * @returns {Request}
 */
module.exports.get = function get (url, options) {
  options = options || {};

  const key = options.ignoreQuery
    ? url.split('?')[0]
    : url;
  let req = cache[key];

  if (req) {
    // Return cached
    if (!options.abort) return req;
    // Abort existing
    req.abort();
  }

  req = oldGet(url);
  req.__agentCacheKey = key;
  if (options.id) req.__agentId = options.id;

  cache[key] = req;

  return req;
};

/**
 * Abort all outstanding requests
 * @param {String|Function} filter
 */
module.exports.abortAll = function abortAll (filter) {
  const filterById = filter && 'string' == typeof filter;

  for (const key in cache) {
    const req = cache[key];
    const shouldAbort = filter
      ? filterById
        ? filter == req.__agentId
        : filter(req)
      : true;

    if (shouldAbort) {
      req.abort();
      delete cache[key];
    }
  }
};

/**
 * Initiate request, invoking callback 'fn' on complete.
 * Overrides Superagent Request.end()
 * @param {Function} fn(err, res)
 * @returns {Request}
 */
Request.prototype.end = function end (fn) {
  // Restore normal behaviour if not using Agent
  if (!this.__agentCacheKey) {
    oldEnd.call(this, fn);
    return this;
  }

  const start = Date.now();

  // Handle end
  const onEnd = (err, res) => {
    if (err || res.error) {
      let status, msg;

      // Error or response 4xx/5xx
      if (res && res.error) {
        status = res.status;
        msg = res.error.message;
      } else if (err) {
        // Probably aborted (client)
        if (err.crossDomain) return;

        if (err.timeout) {
          status = STATUS_TIMEOUT;
          msg = 'request timed out';
        }

        status = status || err.statusCode || 500;
        msg = msg || err.message || 'request errored';
      }

      err = Error(msg);
      err.status = status;
    }

    if (res) res.duration = Date.now() - start;

    delete cache[this.__agentCacheKey];

    fn(err, res);
  };

  oldEnd.call(this, onEnd);

  return this;
};