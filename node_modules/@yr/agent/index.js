/**
 * Superagent powered request
 * https://github.com/yr/agent
 * @copyright Yr
 * @license MIT
 */

'use strict';

var superagent = require('superagent');

var STATUS_TIMEOUT = 504;

var Request = superagent.Request;
var oldEnd = Request.prototype.end;
var oldGet = superagent.get;
var cache = {};

module.exports = superagent;

/**
 * GET request for 'url'
 * @param {String} url
 * @param {Object} [options]
 *  - {Boolean} abort
 *  - {String} id
 *  - {Boolean} ignoreQuery
 * @returns {Request}
 */
module.exports.get = function get(url, options) {
  options = options || {};

  var key = options.ignoreQuery ? url.split('?')[0] : url;
  var req = cache[key];

  if (req) {
    // Return cached
    if (!options.abort) return req;
    // Abort existing
    req.abort();
  }

  req = oldGet(url);
  req.__agentCacheKey = key;
  if (options.id) req.__agentId = options.id;

  cache[key] = req;

  return req;
};

/**
 * Abort all outstanding requests
 * @param {String|Function} filter
 */
module.exports.abortAll = function abortAll(filter) {
  var filterById = filter && 'string' == typeof filter;

  for (var key in cache) {
    var req = cache[key];
    var shouldAbort = filter ? filterById ? filter == req.__agentId : filter(req) : true;

    if (shouldAbort) {
      req.abort();
      delete cache[key];
    }
  }
};

/**
 * Initiate request, invoking callback 'fn' on complete.
 * Overrides Superagent Request.end()
 * @param {Function} fn(err, res)
 * @returns {Request}
 */
Request.prototype.end = function end(fn) {
  var _this = this;

  // Restore normal behaviour if not using Agent
  if (!this.__agentCacheKey) {
    oldEnd.call(this, fn);
    return this;
  }

  var start = Date.now();

  // Handle end
  var onEnd = function onEnd(err, res) {
    if (err || res.error) {
      var status = void 0,
          msg = void 0;

      // Error or response 4xx/5xx
      if (res && res.error) {
        status = res.status;
        msg = res.error.message;
      } else if (err) {
        // Probably aborted (client)
        if (err.crossDomain) return;

        if (err.timeout) {
          status = STATUS_TIMEOUT;
          msg = 'request timed out';
        }

        status = status || err.statusCode || 500;
        msg = msg || err.message || 'request errored';
      }

      err = Error(msg);
      err.status = status;
    }

    if (res) res.duration = Date.now() - start;

    delete cache[_this.__agentCacheKey];

    fn(err, res);
  };

  oldEnd.call(this, onEnd);

  return this;
};